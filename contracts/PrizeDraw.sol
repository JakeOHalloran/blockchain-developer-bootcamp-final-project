// SPDX-License-Identifier: UNLICENSED"

pragma solidity ^0.8.7;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

/**
* @title A prize draw for ERC20 tokens
* @author Jake O'Halloran
* @notice You can use this contract to run a basic prize draw for your ERC20 token community
* @dev Ensure the contract address has sufficient LINK to allow for the winner to be selected
*/
contract PrizeDrawContract is VRFConsumerBase, Ownable {

    /// @notice Tracks whether a prize draw is running or not
    enum State {
        IDLE,
        RUNNING
    }

    using SafeERC20 for IERC20;

    /// @notice Log what random number was received from Chainlink
    event NumberReceived(uint256 randomNumber);

    /// @notice Log the results of a draw
    event WinnerEvent(address payable winner, uint ticket, uint winnings, uint random);

    /// @notice Log when a draw was canceled
    event CancelEvent(uint balance, uint id, uint tickets, uint players);

    /// @notice Log when a ticket was bought for a draw
    event BuyEvent(address player, uint ticketAmount, uint ticketPrice, uint requiredToken, bool prevBuyer);

    /// @notice represents a single draw
    struct PrizeDraw {
        uint ticketPrice;
        mapping(uint => address) prizeDrawingPool;
        mapping(address => uint) ticketsPerPlayer;
        mapping(address => uint) tokenSpentPerPlayer;
        mapping(uint => address) players;
        uint totalTickets;
        uint totalPlayers;
        uint winningTicket;
        address payable winner;
        string date;
        uint finalPool;
    }

    mapping(uint => PrizeDraw) internal prizeDraws;
    uint internal currentID = 0;
    uint internal previousID = 0;

    /// @notice Log when a ticket was bought for a draw
    State public currentState = State.IDLE;
    
    /// @notice variables for chainlink
    bytes32 internal keyHash;
    uint256 internal fee;
    uint256 internal randomResult;

    /// @notice the ERC20 token used by the smart contract
    IERC20 public prizeDrawToken;

    /// @notice modifier to ensure a prize draw was created
    modifier prizeDrawCreated() {
        require(previousID < currentID, "Must have created a prize draw");
        _;
    }
    
    /**
    * @notice to ensure we are in the correct state for a function to run
    * @param state the state that the current state will be compared with
    */
    modifier inState(State state) {
        require(state == currentState, 'current state does not allow this');
        _;
    }
    
    /// @notice modifier to ensure the prize draw tickets have a value
    modifier ticketPriceSet() {
        require(prizeDraws[currentID].ticketPrice > 0, 'ticket price needs to be set');
        _;
    }

    /// @param tokenAddress The erc20 token used for the prize draws
    constructor(address tokenAddress) 
        VRFConsumerBase(
            0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9, // VRF Coordinator
            0xa36085F69e2889c224210F603D836748e7dC0088  // LINK Token
        )
    {
        keyHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4;
        fee = 0.1 * 10 ** 18;

        prizeDrawToken = IERC20(tokenAddress);
    }
    
    /**
    * @notice Request a random number from chainlink
    * @return requestId the id of the random number request
    */
    function getRandomNumber() public onlyOwner returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK - fill contract with faucet");
        return requestRandomness(keyHash, fee);
    }

    /**
    * @notice function called by the chainlink oracle when random number has been generated
    * @param requestId the id of the random number request
    * @param randomness the random number generated by chainlink
    * @dev frontend needs to be listening for the NumberReceived event
    * @inheritdoc VRFConsumerBase
    */
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        randomResult = randomness;
        emit NumberReceived(randomResult);
    }

    /// @notice create a new prize draw
    function createPrizeDraw() external onlyOwner inState(State.IDLE) {
        currentID++;

        PrizeDraw storage newPrizeDraw = prizeDraws[currentID];
    }
    
    /**
    * @notice set the ticket price for the current prize draw
    * @param _ticketPrice the price, i.e how many tokens to purchase a ticket
    */
    function setTicketPrice(uint _ticketPrice) external onlyOwner prizeDrawCreated inState(State.IDLE) {
        require(_ticketPrice > 0, 'ticket price must be greater than 0');
        prizeDraws[currentID].ticketPrice = _ticketPrice;
    }

    /**
    * @notice set the date that the winner will be selected for the current prize draw
    * @param date the date string
    */
    function saveDate(string memory date) external onlyOwner {
        prizeDraws[currentID].date = date;
    }
    
    /// @notice start the current prize draw
    function startPrizeDraw() external onlyOwner ticketPriceSet inState(State.IDLE) {
        currentState = State.RUNNING;
    }
    
    /**
    * @notice receive tokens and assign tickets to the address
    * @param ticketAmount number of tickets to user is trying to buy
    * @return returns true when tickets have been purchased succesfully
    */
    function buyTickets(uint ticketAmount) external inState(State.RUNNING) ticketPriceSet returns(bool) {
        require(ticketAmount > 0, "must buy at least 1 ticket");

        bool prevBuyer = false;
        
        uint requiredToken = prizeDraws[currentID].ticketPrice * ticketAmount;

        uint requiredToken_toWei = requiredToken * 10 ** 18;
        
        prizeDrawToken.safeTransferFrom(msg.sender, address(this), requiredToken_toWei);

        // has player bought ticket before?
        if(prizeDraws[currentID].ticketsPerPlayer[msg.sender] == 0) {
            prizeDraws[currentID].totalPlayers++;
            prizeDraws[currentID].players[prizeDraws[currentID].totalPlayers] = msg.sender;
        } else {
            prevBuyer = true;
        }

        prizeDraws[currentID].ticketsPerPlayer[msg.sender] += ticketAmount;
        prizeDraws[currentID].tokenSpentPerPlayer[msg.sender] += requiredToken_toWei;

        for(uint i = 1; i <= ticketAmount; i++) {
            prizeDraws[currentID].prizeDrawingPool[prizeDraws[currentID].totalTickets+i] = msg.sender;
        }
        
        prizeDraws[currentID].totalTickets += ticketAmount;

        emit BuyEvent(msg.sender, ticketAmount, prizeDraws[currentID].ticketPrice, requiredToken_toWei, prevBuyer);

        return true;
    }
    
    /// @notice owner picks the winner of the current prize draw at random, the winner receives the prize pool tokens
    function pickWinner() external onlyOwner inState(State.RUNNING) {
        prizeDraws[currentID].winningTicket = (randomResult % prizeDraws[currentID].totalTickets) + 1;
        prizeDraws[currentID].finalPool = prizeDrawToken.balanceOf(address(this));
        prizeDraws[currentID].winner = payable(prizeDraws[currentID].prizeDrawingPool[prizeDraws[currentID].winningTicket]);

        currentState = State.IDLE;
        previousID = currentID;
        
        prizeDrawToken.safeTransfer(prizeDraws[currentID].winner, prizeDrawToken.balanceOf(address(this)));

        emit WinnerEvent(prizeDraws[currentID].winner, prizeDraws[currentID].winningTicket, prizeDraws[currentID].finalPool, randomResult);
    }
    
    /// @notice end the current prize draw and refund all players their tokens
    function cancelPrizeDraw() external onlyOwner inState(State.RUNNING) {
        emit CancelEvent(prizeDrawToken.balanceOf(address(this)), currentID, prizeDraws[currentID].totalTickets, prizeDraws[currentID].totalPlayers);

        currentState = State.IDLE;
        previousID = currentID;

        for(uint i = 1; i <= prizeDraws[currentID].totalPlayers; i++) {
            prizeDrawToken.safeTransfer(prizeDraws[currentID].players[i], prizeDraws[currentID].tokenSpentPerPlayer[prizeDraws[currentID].players[i]]);
        }
    }

    /**
    * @notice Allows the current owner to transfer control of the contract to a newOwner.
    * @param newOwner The address to transfer ownership to.
    */
    function _transferOwnership(address newOwner) public onlyOwner {
        transferOwnership(newOwner);
    }
    
    /**
    * @notice shows everyone what they're playing for, the prize pool
    * @return newOwner The address to transfer ownership to.
    */
    function getTotalPrize() external view returns(uint256) {
        return prizeDrawToken.balanceOf(address(this));
    }
    
    /// @notice a withdraw function to avoid locking your LINK in the contract
    function withdrawLink() external onlyOwner {
        LINK.transfer(owner(), LINK.balanceOf(address(this)));
    }
    
    /**
    * @notice determine how much link is left in the contract
    * @return the link balance for this contract
    */
    function getRemainingLINK() external view onlyOwner returns (uint256) {
        return LINK.balanceOf(address(this));
    }

    /**
    * @notice gets the current prize draws ticket price
    * @return the current prize draws ticket price
    */
    function getTicketPrice() external view returns (uint) {
        return prizeDraws[currentID].ticketPrice;
    }

    /**
    * @notice gets the total number of players for the current prize draw
    * @return the total players for the current draw
    */
    function getPrizeDrawPlayers() external view returns (uint) {
        return prizeDraws[currentID].totalPlayers;
    }

    /**
    * @notice gets the total number of tickets bought for the current prize draw
    * @return the total tickets for the current draw
    */
    function getPrizeDrawTickets() external view returns (uint) {
        return prizeDraws[currentID].totalTickets;
    }

    /**
    * @notice gets the date the current prize draw will be ended by the owner
    * @return the current draws date
    */
    function getPrizeDrawDate() external view returns (string memory) {
        return prizeDraws[currentID].date;
    }

    /**
    * @notice gets the total number of tickets bought for the current prize draw
    * @return the total tickets for the current draw
    */
    function getPreviousWinner() external view returns (address) {
        return prizeDraws[previousID].winner;
    }

    /**
    * @notice gets the total amount of tokens the winner of the last prize draw received
    * @return the amount of tokens won in the previous prize draw
    */
    function getPreviousPrize() external view returns (uint) {
        return prizeDraws[previousID].finalPool;
    }

    /**
    * @notice gets the total tickets purchased by a specific player
    * @param player the address of a player
    * @return the amount of tickets owned by the player
    */
    function getTicketsPerPlayer(address player) external view returns (uint) {
        return prizeDraws[currentID].ticketsPerPlayer[player];
    }

    /**
    * @notice pick a winner for the current prize draw, winner will always be the same
    * @dev function used for unit tests only
    */
    function pickWinnerTest() external onlyOwner inState(State.RUNNING) {
        prizeDraws[currentID].winningTicket = 3;
        
        prizeDraws[currentID].winner = payable(prizeDraws[currentID].prizeDrawingPool[prizeDraws[currentID].winningTicket]);

        currentState = State.IDLE;

        previousID = currentID;
        
        prizeDrawToken.safeTransfer(prizeDraws[currentID].winner, prizeDrawToken.balanceOf(address(this)));
    }

    /**
    * @notice gets the id for the previous prize draw
    * @dev function used for unit tests only
    * @return the previous prize draws id
    */
    function getPrevPrizeDraw() external view onlyOwner returns (uint) {
        return previousID;
    }

    /**
    * @notice gets the id for the current prize draw
    * @dev function used for unit tests only
    * @return the current prize draws id
    */
    function getPrizeDrawCount() external view onlyOwner returns (uint) {
        return currentID;
    }

    /**
    * @notice see who owns a particular ticket for the current draw
    * @param ticketNumber the tickets number
    * @dev function used for unit tests only
    * @return the address of the ticket owner
    */
    function getTicketAddress(uint ticketNumber) external view onlyOwner returns (address) {
        return prizeDraws[currentID].prizeDrawingPool[ticketNumber];
    }

    /**
    * @notice see which ticket was selected as the winning ticket for the current prize draw
    * @dev function used for unit tests only
    * @return the winning ticket number
    */
    function getWinningTicket() external view onlyOwner returns (uint) {
        return prizeDraws[currentID].winningTicket;
    }

    /**
    * @notice see which player was owns the winning ticket for the current prize draw
    * @dev function used for unit tests only
    * @return the winning address
    */
    function getWinnerAddress() external view onlyOwner returns (address payable) {
        return prizeDraws[currentID].winner;
    }

    /**
    * @notice gets the total tokens spent by a specific player
    * @param player the address of a player
    * @dev function used for unit tests only
    * @return the amount of tokens spent by the player
    */
    function getTokensSpentPerPlayer(address player) external view returns (uint) {
        return prizeDraws[currentID].tokenSpentPerPlayer[player];
    }
}